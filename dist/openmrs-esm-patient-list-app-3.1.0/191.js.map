{"version":3,"file":"191.js","mappings":"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","sources":["webpack://@openmrs/esm-patient-list-app/./src/api/types.ts","webpack://@openmrs/esm-patient-list-app/./src/api/api-remote.ts","webpack://@openmrs/esm-patient-list-app/./src/api/api-local.ts","webpack://@openmrs/esm-patient-list-app/./src/api/api.ts","webpack://@openmrs/esm-patient-list-app/./src/api/queries.ts","webpack://@openmrs/esm-patient-list-app/./src/utils/use-async.hook.ts"],"sourcesContent":["import { OpenmrsResource } from '@openmrs/esm-api';\n\nexport enum PatientListType {\n  SYSTEM,\n  USER,\n}\n\nexport interface PatientList {\n  id: string;\n  display: string;\n  description: string;\n  type: PatientListType;\n  size: number;\n  isStarred: boolean;\n  options?: Array<PatientListOption>;\n}\n\nexport interface PatientListUpdate {\n  isStarred: boolean;\n}\n\nexport interface PatientListFilter {\n  isStarred?: boolean;\n  name?: string;\n  type?: PatientListType;\n}\n\nexport interface PatientListOption {\n  type: string;\n  name: string;\n  value: any;\n}\n\nexport interface PatientListMember {\n  id: string;\n}\n\nexport interface AddPatientData {\n  patient: string;\n  cohort: string;\n  startDate: string;\n}\n\nexport interface OpenmrsCohort {\n  uuid: string;\n  resourceVersion: string;\n  name: string;\n  description: string;\n  attributes: Array<any>;\n  links: Array<any>;\n  location: Location | null;\n  groupCohort: boolean | null;\n  startDate: string | null;\n  endDate: string | null;\n  voidReason: string | null;\n  voided: boolean;\n  isStarred?: boolean;\n  type?: string;\n  size: number;\n  cohortType?: CohortType;\n}\n\nexport interface OpenmrsCohortRef {\n  cohort: OpenmrsCohortMember;\n}\n\nexport interface OpenmrsCohortMember {\n  attributes: Array<any>;\n  description: string;\n  endDate: string;\n  startDate: string;\n  name: string;\n  uuid: string;\n  patient: OpenmrsResource;\n}\n\nexport interface CohortResponse<T> {\n  results: Array<T>;\n  error: any;\n}\n\nexport interface NewCohortData {\n  name: string;\n  description: string;\n  location: string;\n  cohortType: string;\n}\n\nexport interface CohortType {\n  display: string;\n  uuid: string;\n}\n","import { openmrsFetch } from '@openmrs/esm-framework';\nimport {\n  AddPatientData,\n  CohortResponse,\n  NewCohortData,\n  OpenmrsCohort,\n  OpenmrsCohortMember,\n  OpenmrsCohortRef,\n  PatientListFilter,\n  PatientListMember,\n  PatientListType,\n} from './types';\n\nexport const cohortUrl = '/ws/rest/v1/cohortm';\n\nasync function postData(url: string, data = {}, ac = new AbortController()) {\n  const response = await openmrsFetch(url, {\n    signal: ac.signal,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(data),\n  });\n  return response.data;\n}\n\nasync function deleteData(url: string, data = {}, ac = new AbortController()) {\n  const response = await openmrsFetch(url, {\n    signal: ac.signal,\n    method: 'DELETE',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(data),\n  });\n  return response.data;\n}\n\nexport async function getAllPatientLists(filter: PatientListFilter = {}, ac = new AbortController()) {\n  const custom = 'custom:(uuid,name,description,display,size,attributes)';\n  const query: Array<[string, string]> = [['v', custom]];\n\n  if (filter.name !== undefined && filter.name !== '') {\n    query.push(['q', filter.name]);\n  }\n\n  if (filter.isStarred !== undefined) {\n    // TODO: correct this; it definitely is \"attributes\", but then we'd get back a 500 right now.\n    query.push(['attribute', `starred:${filter.isStarred}`]);\n  }\n\n  if (filter.type !== undefined) {\n    const type =\n      filter.type === PatientListType.SYSTEM ? '\"Patient List Type\":\"System\"' : '\"Patient List Type\":\"My lists\"';\n    query.push(['attributes', type]);\n  }\n\n  const params = query.map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');\n  const {\n    data: { results, error },\n  } = await openmrsFetch<CohortResponse<OpenmrsCohort>>(`${cohortUrl}/cohort?${params}`, {\n    signal: ac.signal,\n  });\n\n  if (error) {\n    throw error;\n  }\n\n  return results;\n}\n\nexport async function getPatientListMembers(cohortUuid: string, ac = new AbortController()) {\n  const {\n    data: { results, error },\n  } = await openmrsFetch<CohortResponse<OpenmrsCohortMember>>(\n    `${cohortUrl}/cohortmember?cohort=${cohortUuid}&v=default`,\n    {\n      signal: ac.signal,\n    },\n  );\n\n  if (error) {\n    throw error;\n  }\n\n  const searchQuery = results.map((p) => p.patient.uuid).join(',');\n  const result = await openmrsFetch(`/ws/fhir2/R4/Patient/_search?_id=${searchQuery}`, {\n    method: 'POST',\n    signal: ac.signal,\n  });\n\n  const patients: Array<PatientListMember> = result.data.entry.map((e) => e.resource);\n  return patients;\n}\n\nexport async function getPatientListIdsForPatient(patientUuid: string, ac = new AbortController()) {\n  const {\n    data: { results, error },\n  } = await openmrsFetch<CohortResponse<OpenmrsCohortRef>>(\n    `${cohortUrl}/cohortmember?patient=${patientUuid}&v=default`,\n    {\n      signal: ac.signal,\n    },\n  );\n\n  if (error) {\n    throw error;\n  }\n\n  return results.map((ref) => ref.cohort.uuid);\n}\n\nexport async function addPatientToList(data: AddPatientData, ac = new AbortController()) {\n  return postData(`${cohortUrl}/cohortmember`, data, ac);\n}\n\nexport async function createPatientList(cohort: NewCohortData, ac = new AbortController()) {\n  return postData(\n    `${cohortUrl}/cohort/`,\n    {\n      ...cohort,\n      startDate: new Date(),\n      groupCohort: false,\n      definitionHandlerClassname: 'org.openmrs.module.cohort.definition.handler.DefaultCohortDefinitionHandler',\n    },\n    ac,\n  );\n}\n\nexport async function editPatientList(cohortUuid: string, cohort: NewCohortData, ac = new AbortController()) {\n  return postData(`${cohortUrl}/cohort/${cohortUuid}`, cohort, ac);\n}\n\nexport async function deletePatientList(cohortUuid: string, ac = new AbortController()) {\n  return deleteData(\n    `${cohortUrl}/cohort/${cohortUuid}`,\n    {\n      voidReason: '',\n    },\n    ac,\n  );\n}\n","import { isOfflineUuid, offlineUuidPrefix, syncOfflinePatientData } from '@openmrs/esm-framework';\nimport Dexie, { Table } from 'dexie';\nimport { PatientList, PatientListMember, PatientListUpdate, PatientListType, PatientListFilter } from './types';\nimport uniqBy from 'lodash-es/uniqBy';\nimport { notifyOnPatientAdded } from '../global-store';\n\nexport const offlinePatientListId = `${offlineUuidPrefix}l0c4l000-5240-4b9b-b5d6-000000000001`;\n\n/**\n * A basic template of those patient lists that are known to be stored on the user's local device.\n * These values are, when modified by the user, enriched with metadata stored in an IndexedDB.\n */\nconst knownLocalPatientListTemplates: Array<PatientList> = [\n  {\n    id: offlinePatientListId,\n    display: 'Offline Patients',\n    description: 'Patients available while offline.',\n    isStarred: false,\n    size: 0,\n    type: PatientListType.USER,\n  },\n];\n\n/**\n * Returns all patient lists of the given user stored locally on the user's device.\n * @param userId The ID of the user whose patient list information should be retrieved.\n */\nexport async function getAllLocalPatientLists(\n  userId: string,\n  filter: PatientListFilter = {},\n): Promise<Array<PatientList>> {\n  const allMetadata = await findAllPatientListMetadata(userId);\n  const patientLists = knownLocalPatientListTemplates.map((template) => {\n    const associatedMetadata = allMetadata.find((metadata) => metadata.patientListId === template.id);\n    return {\n      ...template,\n      isStarred: associatedMetadata?.isStarred ?? template.isStarred,\n      size: associatedMetadata?.members.length ?? template.size,\n    };\n  });\n\n  return patientLists.filter(\n    (patientList) =>\n      (filter.name === undefined || patientList.display.toLowerCase().includes(filter.name.toLowerCase())) &&\n      (filter.isStarred === undefined || patientList.isStarred === filter.isStarred) &&\n      (filter.type === undefined || patientList.type == filter.type),\n  );\n}\n\nexport async function getLocalPatientListIdsForPatient(userId: string, patientId: string): Promise<Array<string>> {\n  const allMetadata = await findAllPatientListMetadata(userId);\n  const metadataWithPatients = allMetadata.filter((metadata) => metadata.members.some((x) => x.id === patientId));\n  return metadataWithPatients.map((metadata) => metadata.patientListId);\n}\n\n/**\n * Returns the members of the patient list with the given {@link patientListId} stored locally on the user's device.\n * Returns an empty array if the patient list is not found.\n */\nexport async function getLocalPatientListMembers(\n  userId: string,\n  patientListId: string,\n): Promise<Array<PatientListMember>> {\n  ensureIsLocalPatientList(patientListId);\n  const metadata = await getOrCreateMetadataEntry(userId, patientListId);\n  return metadata.members ?? [];\n}\n\n/**\n * Updates the local patient list with the given update values.\n */\nexport async function updateLocalPatientList(userId: string, patientListId: string, update: PatientListUpdate) {\n  ensureIsLocalPatientList(patientListId);\n\n  const db = new PatientListDb();\n  const initialMetadata = await getOrCreateMetadataEntry(userId, patientListId, db);\n  const updatedMetadata = {\n    ...initialMetadata,\n    ...update,\n  };\n\n  await db.patientListMetadata.put(updatedMetadata);\n}\n\nexport async function addPatientToLocalPatientList(userId: string, patientListId: string, patientId: string) {\n  ensureIsLocalPatientList(patientListId);\n\n  const db = new PatientListDb();\n  const entry = await getOrCreateMetadataEntry(userId, patientListId, db);\n\n  entry.members.push({ id: patientId });\n  entry.members = uniqBy(entry.members, (x) => x.id);\n\n  await db.patientListMetadata.put(entry);\n\n  if (patientListId === offlinePatientListId) {\n    syncOfflinePatientData(patientId);\n  }\n}\n\nexport async function removePatientFromLocalPatientList(userId: string, patientListId: string, patientId: string) {\n  ensureIsLocalPatientList(patientListId);\n  const db = new PatientListDb();\n  const entry = await getOrCreateMetadataEntry(userId, patientListId, db);\n  entry.members = entry.members.filter((x) => x.id !== patientId);\n  await db.patientListMetadata.put(entry);\n}\n\nasync function findAllPatientListMetadata(userId: string, db = new PatientListDb()) {\n  return await db.patientListMetadata.where({ userId }).toArray();\n}\n\nasync function getOrCreateMetadataEntry(userId: string, patientListId: string, db = new PatientListDb()) {\n  ensureIsLocalPatientList(patientListId);\n  const metadata = await db.patientListMetadata.where({ userId, patientListId }).first();\n\n  if (metadata) {\n    return metadata;\n  } else {\n    const defaultMetadata: LocalPatientListMetadata = {\n      userId,\n      patientListId,\n      isStarred: false,\n      members: [],\n    };\n\n    await db.patientListMetadata.put(defaultMetadata);\n    return defaultMetadata;\n  }\n}\n\nfunction ensureIsLocalPatientList(patientListOrId: string | PatientList) {\n  const id = typeof patientListOrId === 'string' ? patientListOrId : patientListOrId.id;\n\n  if (!isOfflineUuid(id)) {\n    throw new Error(\n      'The given patient list is not a device local patient list. It cannot be accessed with this functions.',\n    );\n  }\n}\n\nclass PatientListDb extends Dexie {\n  patientListMetadata: Table<LocalPatientListMetadata, number>;\n\n  constructor() {\n    super('EsmPatientList');\n    this.version(2).stores({ patientListMetadata: '++id,&[userId+patientListId]' });\n    this.patientListMetadata = this.table('patientListMetadata');\n  }\n}\n\ninterface LocalPatientListMetadata {\n  id?: number;\n  userId: string;\n  patientListId: string;\n  isStarred: boolean;\n  members: Array<PatientListMemberRef>;\n}\n\ninterface PatientListMemberRef {\n  id: string;\n}\n","import { isOfflineUuid } from '@openmrs/esm-framework';\nimport {\n  addPatientToLocalPatientList,\n  getAllLocalPatientLists,\n  getLocalPatientListIdsForPatient,\n  getLocalPatientListMembers,\n  updateLocalPatientList,\n} from './api-local';\nimport { addPatientToList, getAllPatientLists, getPatientListIdsForPatient, getPatientListMembers } from './api-remote';\nimport {\n  AddPatientData,\n  OpenmrsCohort,\n  PatientList,\n  PatientListFilter,\n  PatientListType,\n  PatientListUpdate,\n} from './types';\n\nexport async function getLocalAndRemotePatientLists(\n  userId: string,\n  filter?: PatientListFilter,\n  abortController = new AbortController(),\n): Promise<Array<PatientList>> {\n  const localPromise = getAllLocalPatientLists(userId, filter);\n  const remotePromise = getAllPatientLists(filter, abortController).then((cohorts) =>\n    cohorts.map(mapCohortToPatientList),\n  );\n  return awaitAllAndMerge(localPromise, remotePromise);\n}\n\nfunction mapCohortToPatientList(cohort: OpenmrsCohort): PatientList {\n  return {\n    id: cohort.uuid,\n    display: cohort.name,\n    description: cohort.description,\n    type: cohort.attributes.find((att) => att?.cohortAttributeType?.name === 'Patient List Type')?.value,\n    size: cohort.size,\n    isStarred: false, // TODO,\n  };\n}\n\nexport async function getLocalAndRemotePatientListsForPatient(\n  userId: string,\n  patientId: string,\n  abortController?: AbortController,\n) {\n  const localPromise = getLocalPatientListIdsForPatient(userId, patientId);\n  const remotePromise = getPatientListIdsForPatient(patientId, abortController);\n  return awaitAllAndMerge(localPromise, remotePromise);\n}\n\nfunction awaitAllAndMerge<T>(...promises: Array<Promise<Array<T>>>): Promise<Array<T>> {\n  return Promise.all(promises).then((lists) => [].concat.apply([], lists));\n}\n\nexport function getLocalAndRemotePatientListMembers(\n  userId: string,\n  patientListId: string,\n  abortController?: AbortController,\n) {\n  return isOfflineUuid(patientListId)\n    ? getLocalPatientListMembers(userId, patientListId)\n    : getPatientListMembers(patientListId, abortController);\n}\n\nexport function addPatientToLocalOrRemotePatientList(\n  userId: string,\n  data: AddPatientData,\n  abortController = new AbortController(),\n) {\n  if (isOfflineUuid(data.cohort)) {\n    return addPatientToLocalPatientList(userId, data.cohort, data.patient);\n  } else {\n    return addPatientToList(data, abortController);\n  }\n}\n\nexport function updateLocalOrRemotePatientList(\n  userId: string,\n  patientListId: string,\n  update: PatientListUpdate,\n  abortController?: AbortController,\n) {\n  if (isOfflineUuid(patientListId)) {\n    return updateLocalPatientList(userId, patientListId, update);\n  } else {\n    //updatePatientListDetails(listUuid, { isStarred: star }).then(() => setChanged((c) => !c));\n  }\n}\n","import { PatientList, PatientListFilter, PatientListMember } from './types';\nimport { useAsync, useAsyncQuery } from '../utils/use-async.hook';\nimport {\n  getLocalAndRemotePatientListMembers,\n  getLocalAndRemotePatientLists,\n  getLocalAndRemotePatientListsForPatient,\n  updateLocalOrRemotePatientList,\n} from './api';\nimport { getLocalPatientListMembers, offlinePatientListId, removePatientFromLocalPatientList } from './api-local';\nimport { fetchCurrentPatient, openmrsFetch, FetchResponse } from '@openmrs/esm-framework';\nimport { OpenmrsCohort, OpenmrsCohortMember, CohortResponse, cohortUrl, CohortType } from '.';\nimport useSWR from 'swr';\n\n/**\n * A hook for querying all local and remote patient lists belonging to a given user,\n * optionally filtered by the specified {@link filter}.\n */\nexport function usePatientListDataQuery(userId?: string, filter?: PatientListFilter) {\n  return useAsyncQuery(\n    ({ abortController }) => {\n      if (!userId) {\n        return Promise.resolve<Array<PatientList>>([]);\n      }\n\n      return getLocalAndRemotePatientLists(userId, filter, abortController);\n    },\n    [userId, filter],\n  );\n}\n\n/**\n * A hook for querying all members of a given local or remote patient list.\n */\nexport function useGetAllPatientListMembersQuery(userId?: string, patientListId?: string) {\n  return useAsyncQuery(() => {\n    if (!userId || !patientListId) {\n      return Promise.resolve<Array<PatientListMember>>([]);\n    }\n\n    return getLocalAndRemotePatientListMembers(userId, patientListId);\n  }, [userId, patientListId]);\n}\n\n/**\n * A hook for querying all local and remote patient lists that exist for a given user,\n * but without those patient lists where a specific patient has already been added as a member.\n *\n * This is intended for displaying all lists to which a given patient can still be added.\n */\nexport function useGetAllPatientListsWithoutPatientQuery(userId?: string, patientUuid?: string) {\n  return useAsyncQuery(\n    async ({ abortController }) => {\n      if (!userId || !patientUuid) {\n        return [];\n      }\n\n      const [allLists, listsIdsOfThisPatient] = await Promise.all([\n        getLocalAndRemotePatientLists(userId, undefined, abortController),\n        getLocalAndRemotePatientListsForPatient(userId, patientUuid, abortController),\n      ]);\n\n      const listsWithoutPatient = allLists.filter((list) => !listsIdsOfThisPatient.includes(list.id));\n      return listsWithoutPatient;\n    },\n    [userId, patientUuid],\n  );\n}\n\nexport function useGetAllPatientsFromOfflineListQuery(userId?: string) {\n  return useAsyncQuery<Array<fhir.Patient>>(async () => {\n    if (!userId) {\n      return [];\n    }\n\n    const allPatientUuids = await getLocalPatientListMembers(userId, offlinePatientListId);\n    const patients: Array<{ data: fhir.Patient } | null> = await Promise.all(\n      allPatientUuids.map(({ id }) => fetchCurrentPatient(id)),\n    );\n\n    return patients.filter(Boolean).map((result) => result.data);\n  }, [userId]);\n}\n\nexport interface ToggleStarredMutationArgs {\n  userId: string;\n  patientListId: string;\n  isStarred: boolean;\n}\n\n/**\n * A hook for mutating a local or remote patient list's `isStarred` attribute.\n */\nexport function useToggleStarredMutation() {\n  return useAsync(({ userId, patientListId, isStarred }: ToggleStarredMutationArgs, { abortController }) => {\n    return updateLocalOrRemotePatientList(userId, patientListId, { isStarred }, abortController);\n  });\n}\n\nexport interface RemovePatientsFromOfflinePatientListMutationArgs {\n  userId: string;\n  patientUuids: Array<string>;\n}\n\n/**\n * A hook for removing multiple patients at once from the offline patient list.\n */\nexport function useRemovePatientsFromOfflinePatientListMutation() {\n  return useAsync(async ({ userId, patientUuids }: RemovePatientsFromOfflinePatientListMutationArgs) => {\n    if (!userId) {\n      return;\n    }\n\n    for (const patientUuid of patientUuids) {\n      await removePatientFromLocalPatientList(userId, offlinePatientListId, patientUuid);\n    }\n  });\n}\n\nexport function usePatientListDetails(patientListUuid: string) {\n  const swrResult = useSWR<FetchResponse<OpenmrsCohort>, Error>(`${cohortUrl}/cohort/${patientListUuid}`, openmrsFetch);\n  return { ...swrResult, data: swrResult?.data?.data };\n}\n\nexport function usePatientListMembers(\n  patientListUuid: string,\n  searchQuery: string = '',\n  startIndex: number = 0,\n  pageSize: number = 10,\n  v: string = 'full',\n) {\n  const swrResult = useSWR<FetchResponse<CohortResponse<OpenmrsCohortMember>>, Error>(\n    `${cohortUrl}/cohortmember?cohort=${patientListUuid}&startIndex=${startIndex}&limit=${pageSize}&v=${v}&q=${searchQuery}`,\n    openmrsFetch,\n  );\n  return { ...swrResult, data: swrResult?.data?.data?.results };\n}\n\nexport function useCohortTypes() {\n  const swrResult = useSWR<FetchResponse<CohortResponse<CohortType>>, Error>(`${cohortUrl}/cohorttype`, openmrsFetch);\n  return { ...swrResult, data: swrResult?.data?.data?.results };\n}\n","import { useState, useCallback, useEffect, DependencyList, useRef } from 'react';\n\n/** Encapsulates data passed to every asynchronous function used with {@link useAsync}. */\nexport interface AsyncFnData {\n  /**\n   * An {@link AbortController} which will be aborted when the owning component is unmounted or\n   * when a refetch is triggered.\n   */\n  abortController: AbortController;\n}\n\nexport type AsyncFn<TArgs, TResult> = TArgs extends undefined\n  ? (data: AsyncFnData) => Promise<TResult>\n  : (args: TArgs, data: AsyncFnData) => Promise<TResult>;\n\nexport type RefetchAsyncFn<TArgs, TResult> = TArgs extends undefined\n  ? () => Promise<TResult>\n  : (args: TArgs) => Promise<TResult>;\n\nexport type UseAsyncStatus = 'idle' | 'loading' | 'fetching' | 'success' | 'error';\n\n/**\n * The data returned by the {@link useAsync} and {@link useAsyncQuery} hooks.\n * Provides details about the asynchronous function's lifecycle and its returned data or thrown error\n * and functions for changing that state.\n */\nexport interface UseAsyncState<TArgs, TResult> {\n  status: UseAsyncStatus;\n  isIdle: boolean;\n  isLoading: boolean;\n  isFetching: boolean;\n  isSuccess: boolean;\n  isError: boolean;\n  data?: TResult;\n  error?: any;\n  refetch: RefetchAsyncFn<TArgs, TResult>;\n}\n\n/**\n * Wraps an asynchronous function which receives no parameters and asynchronously produces a result\n * of type {@link TResult}.\n * The function is immediately invoked.\n *\n * See {@link useAsync} for additional details.\n * @param fn An asynchronous function whose lifecycle should be wrapped by this hook.\n * @param deps Dependencies of the function.\n * @returns An {@link UseAsyncState} which represents the asynchronous function's lifecycle.\n */\nexport function useAsyncQuery<TResult = unknown>(fn: AsyncFn<undefined, TResult>, deps: DependencyList = []) {\n  const state = useAsync<undefined, TResult>(fn, deps);\n  const refetch = state.refetch;\n\n  useEffect(() => {\n    refetch().catch(() => {});\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n\n  return state;\n}\n\n/**\n * Wraps an asynchronous function which receives an argument of type {@link TArgs} and asynchronously\n * produces a result of type {@link TResult}.\n * Declaratively provides details about the function's execution lifecycle and its returned data\n * or thrown error.\n *\n * Inspired by https://usehooks.com/useAsync but extended with additional functionality like\n * refetching or cancellation.\n * @param fn An asynchronous function whose lifecycle should be wrapped by this hook.\n * @param deps Dependencies of the function.\n * @returns An {@link UseAsyncState} which represents the asynchronous function's lifecycle.\n */\nexport function useAsync<TArgs = unknown, TResult = unknown>(\n  fn: AsyncFn<TArgs, TResult>,\n  deps: DependencyList = [],\n): UseAsyncState<TArgs, TResult> {\n  const abortController = useRef(new AbortController());\n  const isMounted = useRef(true);\n  const [status, setStatus] = useState<UseAsyncStatus>('idle');\n  const [data, setData] = useState<any>(undefined);\n  const [error, setError] = useState<any>(undefined);\n\n  const refetch = useCallback(async (...args) => {\n    abortController.current.abort();\n    abortController.current = new AbortController();\n    setStatus((previousStatus) => (previousStatus === 'idle' ? 'loading' : 'fetching'));\n\n    try {\n      const options: AsyncFnData = { abortController: abortController.current };\n      const newData =\n        args.length === 0 ? await (fn as AsyncFn<undefined, TResult>)(options) : await fn(args[0], options);\n\n      if (isMounted.current) {\n        setStatus('success');\n        setData(newData);\n        setError(undefined);\n      }\n    } catch (e) {\n      if (isMounted.current) {\n        setStatus('error');\n        setError(e);\n      }\n\n      throw e;\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n\n  useEffect(() => {\n    return () => {\n      isMounted.current = false;\n      abortController.current.abort();\n    };\n  }, []);\n\n  return {\n    status,\n    isIdle: status === 'idle',\n    isLoading: status === 'loading',\n    isFetching: status === 'fetching',\n    isSuccess: status === 'success',\n    isError: status === 'error',\n    data,\n    error,\n    refetch: refetch as unknown as RefetchAsyncFn<TArgs, TResult>,\n  };\n}\n"],"names":["PatientListType","cohortUrl","async","postData","url","data","ac","AbortController","response","openmrsFetch","signal","method","headers","body","JSON","stringify","deleteData","getAllPatientLists","filter","custom","query","undefined","name","push","isStarred","type","SYSTEM","params","map","key","value","encodeURIComponent","join","results","error","addPatientToList","createPatientList","cohort","startDate","Date","groupCohort","definitionHandlerClassname","editPatientList","cohortUuid","deletePatientList","voidReason","offlinePatientListId","offlineUuidPrefix","knownLocalPatientListTemplates","id","display","description","size","USER","getAllLocalPatientLists","userId","allMetadata","findAllPatientListMetadata","patientLists","template","associatedMetadata","find","metadata","patientListId","members","length","patientList","toLowerCase","includes","addPatientToLocalPatientList","patientId","ensureIsLocalPatientList","db","PatientListDb","entry","getOrCreateMetadataEntry","uniqBy","x","patientListMetadata","put","syncOfflinePatientData","removePatientFromLocalPatientList","where","toArray","first","defaultMetadata","patientListOrId","isOfflineUuid","Error","Dexie","constructor","super","this","version","stores","table","getLocalAndRemotePatientLists","abortController","localPromise","remotePromise","then","cohorts","mapCohortToPatientList","awaitAllAndMerge","uuid","attributes","att","cohortAttributeType","getLocalAndRemotePatientListsForPatient","some","getLocalPatientListIdsForPatient","patientUuid","ref","getPatientListIdsForPatient","promises","Promise","all","lists","concat","apply","addPatientToLocalOrRemotePatientList","patient","usePatientListDataQuery","useAsyncQuery","resolve","useGetAllPatientListsWithoutPatientQuery","allLists","listsIdsOfThisPatient","list","useGetAllPatientsFromOfflineListQuery","allPatientUuids","getLocalPatientListMembers","fetchCurrentPatient","Boolean","result","useToggleStarredMutation","useAsync","update","updatedMetadata","updateLocalPatientList","updateLocalOrRemotePatientList","useRemovePatientsFromOfflinePatientListMutation","patientUuids","usePatientListDetails","patientListUuid","swrResult","useSWR","usePatientListMembers","searchQuery","startIndex","pageSize","v","useCohortTypes","fn","deps","state","refetch","useEffect","catch","useRef","isMounted","status","setStatus","useState","setData","setError","useCallback","current","abort","previousStatus","options","newData","e","isIdle","isLoading","isFetching","isSuccess","isError"],"sourceRoot":""}